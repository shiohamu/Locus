# リファクタリング計画 v3

作成日: 2025-12-29
最終更新: 2025-12-29

**実装状況**: Phase 1-5 完了 ✅、Phase 6-11 計画中

## 1. 概要

このドキュメントは、Locusプロジェクトの最新のリファクタリング計画をまとめたものです。既存のPhase 1-4が完了し、Phase 5-8が計画されていることを前提に、コードベースの現状を再評価し、さらなる改善点を特定しました。

## 2. 現状分析

### 2.1 既に完了した改善（Phase 1-4）

既存のリファクタリング計画でPhase 1-4が完了しています：

- ✅ **Phase 1**: コード品質の向上（型安全性、テスト、ドキュメント）
- ✅ **Phase 2**: パフォーマンスの最適化（バンドルサイズ、レンダリング、APIリクエスト）
- ✅ **Phase 3**: コードの一貫性の向上（命名規則、コードスタイル）
- ✅ **Phase 4**: アーキテクチャの改善（状態管理、関心の分離、エラーハンドリング）

### 2.2 既に実施されている改善

コードベースを確認した結果、以下の改善は既に実施されています：

- ✅ **データベース層の共通マッピング関数**: `apps/api/src/db/utils/mappers.ts` が存在し、`mapRowToNoteCore`, `mapRowsToNoteCore` が使用されている
- ✅ **クエリビルダー**: `apps/api/src/db/utils/query-builder.ts` が存在し、`createQueryBuilder` が使用されている
- ✅ **エラーハンドリング**: `apps/api/src/utils/errors.ts` と `apps/api/src/middleware/error-handler.ts` が存在
- ✅ **エラー境界**: `apps/web/src/lib/components/ErrorBoundary.svelte` が実装されている

### 2.3 新たに特定された改善点

コードベースを再評価した結果、以下の改善点を特定しました：

#### 2.3.1 型アサーションの削減

**問題点**:
- データベース層で型アサーション（`as`）が59箇所で使用されている
- `row.id as string`, `row.type as NoteType` などの型アサーションが各所で使用されている
- 型安全性が不十分で、実行時エラーのリスクがある

**影響範囲**:
- `apps/api/src/db/*.ts` すべて（17ファイル）
- 特に `notes.ts`, `rss.ts`, `files.ts`, `tags.ts`, `web-clips.ts`, `links.ts`, `search.ts`

**改善効果**:
- 型安全性の向上
- コンパイル時エラー検出の強化
- 実行時エラーのリスク削減

**実装方法**:
- 型ガード関数の追加
- バリデーション関数の実装
- より厳密な型定義の導入

#### 2.3.2 データベース層のエラーハンドリング統一

**問題点**:
- 一部のDB関数でエラーハンドリングが統一されていない
- エラーログの記録が不十分な箇所がある
- カスタムエラー型（`DatabaseError`, `NotFoundError` など）の使用が不十分

**影響範囲**:
- `apps/api/src/db/*.ts` すべて

**改善効果**:
- エラーハンドリングの一貫性向上
- デバッグの容易化
- ユーザーへの適切なエラーメッセージ提供

#### 2.3.3 サービス層のリファクタリング

**問題点**:
- 一部のサービスでビジネスロジックとデータアクセス層の境界が不明確
- サービス間の依存関係が複雑
- テストの容易性が低い

**影響範囲**:
- `apps/api/src/services/*.ts`
- 特に `export/`, `llm/`, `rss-fetcher.ts`, `tag-suggestions.ts`

**改善効果**:
- 関心の分離の明確化
- テストの容易性向上
- コードの再利用性向上

#### 2.3.4 APIルート層のリファクタリング

**問題点**:
- 一部のルートハンドラーでビジネスロジックが直接記述されている
- バリデーションロジックが分散している
- エラーハンドリングが不統一

**影響範囲**:
- `apps/api/src/routes/*.ts`

**改善効果**:
- コードの一貫性向上
- バリデーションロジックの統一
- メンテナンス性の向上

#### 2.3.5 フロントエンドの状態管理最適化

**問題点**:
- `apps/web/src/lib/stores/notes.ts` で、`fileToNoteCore` 関数が複数の `derived` ストアで使用されているが、最適化の余地がある
- 一部の `derived` ストアで不要な再計算が発生している可能性

**影響範囲**:
- `apps/web/src/lib/stores/notes.ts`

**改善効果**:
- パフォーマンスの向上（重複計算の削減）
- コードの可読性向上

#### 2.3.6 テストカバレッジの向上

**問題点**:
- テストファイルは存在するが、カバレッジが不明
- エッジケースのテストが不足している可能性
- 統合テストの充実が必要

**影響範囲**:
- すべてのテストファイル

**改善効果**:
- バグの早期発見
- リファクタリング時の安全性向上
- コード品質の可視化

#### 2.3.7 ドキュメントの整備

**問題点**:
- JSDocコメントが不足している箇所がある
- 複雑な関数やクラスの説明が不十分
- APIエンドポイントのドキュメントが不足

**影響範囲**:
- すべてのソースファイル
- 特に公開API、サービス層、データベース層

**改善効果**:
- コードの理解しやすさ向上
- 新規メンバーのオンボーディング容易化
- メンテナンス性の向上

## 3. リファクタリング計画

### 3.1 Phase 5: 型安全性の向上

**目的**: 型アサーションの削減、型ガードの実装、バリデーション関数の追加

**タスク**:

1. **型ガード関数の作成**
   - `apps/api/src/db/utils/type-guards.ts` を作成
   - `isNoteCoreRow`, `isTagRow`, `isFileRow` などの型ガード関数を実装
   - データベース行の型を安全に検証

2. **バリデーション関数の実装**
   - `apps/api/src/db/utils/validators.ts` を作成
   - データベース行からオブジェクトへの変換時にバリデーションを実行
   - 不正なデータの早期検出

3. **型アサーションの削減**
   - すべてのDBモジュールで型アサーションを型ガードに置き換え
   - 段階的に移行（1モジュールずつ）

4. **型定義の改善**
   - より厳密な型定義の導入
   - `unknown` 型の適切な使用

**影響範囲**:
- `apps/api/src/db/*.ts` すべて（17ファイル）

**推定工数**: 16-20時間

**実装ステップ**:
1. 型ガード関数の作成とテスト
2. バリデーション関数の実装とテスト
3. `notes.ts` のリファクタリング（パイロット）
4. 他のDBモジュールのリファクタリング
5. 既存テストの更新と新規テストの追加

**成功基準**:
- 型アサーションが50%以上削減される
- すべての既存テストが通過する
- 型エラーがコンパイル時に検出される

### 3.2 Phase 6: エラーハンドリングの統一

**目的**: データベース層とAPI層でのエラーハンドリングの統一

**タスク**:

1. **カスタムエラー型の活用**
   - `apps/api/src/utils/errors.ts` の既存エラー型を活用
   - すべてのDB関数で統一されたエラーハンドリング
   - `DatabaseError`, `NotFoundError`, `ValidationError` の適切な使用

2. **エラーハンドリングミドルウェアの改善**
   - `apps/api/src/middleware/error-handler.ts` の改善
   - エラーログの記録を統一
   - ユーザーへの適切なエラーメッセージの提供

3. **データベース層でのエラーハンドリング**
   - すべてのDB関数で統一されたエラーハンドリング
   - エラーログの記録
   - エラー型の適切な使用

4. **API層でのエラーハンドリング**
   - すべてのルートハンドラーで統一されたエラーハンドリング
   - エラーレスポンスの統一

**影響範囲**:
- `apps/api/src/db/*.ts` すべて
- `apps/api/src/routes/*.ts` すべて
- `apps/api/src/middleware/*.ts`

**推定工数**: 8-10時間

**実装ステップ**:
1. 既存のエラー型の確認と拡張
2. エラーハンドリングミドルウェアの改善
3. データベース層でのエラーハンドリングの統一
4. API層でのエラーハンドリングの統一
5. テストの追加

**成功基準**:
- すべてのエラーが適切なエラー型で処理される
- エラーログが適切に記録される
- ユーザーへのエラーメッセージが適切に表示される
- すべての既存テストが通過する

### 3.3 Phase 7: サービス層のリファクタリング

**目的**: サービス層の関心の分離、テストの容易性向上

**タスク**:

1. **サービス層の整理**
   - ビジネスロジックとデータアクセス層の境界を明確化
   - サービス間の依存関係を整理
   - インターフェースの導入（必要に応じて）

2. **依存性注入の改善**
   - サービス間の依存関係を明示化
   - テストの容易性を向上

3. **サービスの分割**
   - 大きなサービスを小さなサービスに分割（必要に応じて）
   - 単一責任の原則に従う

4. **エラーハンドリングの統一**
   - サービス層でのエラーハンドリングを統一

**影響範囲**:
- `apps/api/src/services/*.ts`
- 特に `export/`, `llm/`, `rss-fetcher.ts`, `tag-suggestions.ts`

**推定工数**: 12-16時間

**実装ステップ**:
1. サービス層の現状分析
2. 依存関係の整理
3. サービスの分割・統合（必要に応じて）
4. エラーハンドリングの統一
5. テストの追加・更新

**成功基準**:
- サービス間の依存関係が明確になる
- テストの容易性が向上する
- コードの再利用性が向上する
- すべての既存テストが通過する

### 3.4 Phase 8: APIルート層のリファクタリング

**目的**: APIルート層のコード品質向上、バリデーションの統一

**タスク**:

1. **バリデーションロジックの統一**
   - `apps/api/src/middleware/validation.ts` を作成
   - 共通のバリデーションミドルウェアを実装
   - Zod などのバリデーションライブラリの導入を検討

2. **ビジネスロジックの分離**
   - ルートハンドラーからビジネスロジックを分離
   - サービス層への移行

3. **エラーハンドリングの統一**
   - すべてのルートハンドラーで統一されたエラーハンドリング
   - エラーレスポンスの統一

4. **コードの整理**
   - 重複コードの削減
   - 共通処理の抽出

**影響範囲**:
- `apps/api/src/routes/*.ts` すべて
- `apps/api/src/middleware/*.ts`

**推定工数**: 10-12時間

**実装ステップ**:
1. バリデーションロジックの統一
2. ビジネスロジックの分離
3. エラーハンドリングの統一
4. コードの整理
5. テストの追加・更新

**成功基準**:
- バリデーションロジックが統一される
- ビジネスロジックがサービス層に分離される
- エラーハンドリングが統一される
- すべての既存テストが通過する

### 3.5 Phase 9: フロントエンドの最適化

**目的**: フロントエンドの状態管理とパフォーマンスの最適化

**タスク**:

1. **状態管理の最適化**
   - `apps/web/src/lib/stores/notes.ts` の最適化
   - `derived` ストアの最適化
   - 不要な再計算の削減

2. **パフォーマンスの最適化**
   - 不要な再レンダリングの削減
   - メモ化の適切な使用
   - バンドルサイズの最適化

3. **コードの整理**
   - 未使用コードの削除
   - コンポーネントの分割（必要に応じて）

**影響範囲**:
- `apps/web/src/lib/stores/*.ts`
- `apps/web/src/routes/*.svelte`
- `apps/web/src/lib/components/*.svelte`

**推定工数**: 8-10時間

**実装ステップ**:
1. 状態管理の最適化
2. パフォーマンスの測定と最適化
3. コードの整理
4. テストの更新

**成功基準**:
- 不要な再レンダリングが50%以上削減される
- バンドルサイズが10%以上削減される（可能な場合）
- すべての既存テストが通過する

### 3.6 Phase 10: テストカバレッジの向上

**目的**: テストカバレッジの向上、エッジケースのテスト追加

**タスク**:

1. **テストカバレッジの測定**
   - カバレッジツールの導入（`c8` または `nyc`）
   - 現在のカバレッジを測定
   - カバレッジレポートの生成

2. **不足しているテストケースの追加**
   - エッジケースのテスト
   - エラーハンドリングのテスト
   - 統合テストの充実

3. **テストのリファクタリング**
   - テストヘルパーの改善
   - テストデータの共通化
   - テストの可読性向上

4. **CI/CDへの統合**
   - カバレッジレポートをCI/CDに統合
   - カバレッジ閾値の設定

**影響範囲**:
- すべてのテストファイル
- テスト設定ファイル
- CI/CD設定

**推定工数**: 12-16時間

**実装ステップ**:
1. カバレッジツールの導入と設定
2. 現在のカバレッジの測定
3. 不足しているテストケースの特定
4. テストケースの追加
5. テストのリファクタリング
6. CI/CDへの統合

**成功基準**:
- テストカバレッジが80%以上になる
- すべてのエッジケースがテストされる
- テストの実行時間が許容範囲内である
- CI/CDでカバレッジが可視化される

### 3.7 Phase 11: ドキュメントの整備

**目的**: コードの理解しやすさ向上、メンテナンス性の向上

**タスク**:

1. **JSDocコメントの充実**
   - すべての公開関数・クラスにJSDocコメントを追加
   - パラメータと戻り値の説明
   - 使用例の追加（必要に応じて）

2. **APIドキュメントの整備**
   - APIエンドポイントのドキュメント化
   - リクエスト・レスポンスの型定義
   - エラーレスポンスの説明

3. **アーキテクチャドキュメントの更新**
   - アーキテクチャ図の更新
   - データフローの説明
   - 設計決定の記録

4. **READMEの更新**
   - セットアップ手順の更新
   - 開発ガイドラインの追加
   - コントリビューションガイドの追加

**影響範囲**:
- すべてのソースファイル
- ドキュメントファイル
- README

**推定工数**: 10-12時間

**実装ステップ**:
1. JSDocコメントの充実（優先度の高いファイルから）
2. APIドキュメントの整備
3. アーキテクチャドキュメントの更新
4. READMEの更新

**成功基準**:
- すべての公開APIにJSDocコメントが追加される
- APIドキュメントが整備される
- アーキテクチャドキュメントが最新の状態になる
- READMEが分かりやすくなる

## 4. 実装順序

推奨される実装順序：

1. **Phase 5** - 型安全性の向上（基盤となる改善）
2. **Phase 6** - エラーハンドリングの統一（Phase 5の後に実施しやすい）
3. **Phase 7** - サービス層のリファクタリング（独立して実施可能）
4. **Phase 8** - APIルート層のリファクタリング（Phase 7の後に実施しやすい）
5. **Phase 9** - フロントエンドの最適化（独立して実施可能）
6. **Phase 10** - テストカバレッジの向上（Phase 5-8の変更をテスト）
7. **Phase 11** - ドキュメントの整備（全Phaseの完了後に実施）

## 5. 成功基準

各Phaseの成功基準：

### Phase 5: 型安全性の向上
- 型アサーションが50%以上削減される
- すべての既存テストが通過する
- 型エラーがコンパイル時に検出される

### Phase 6: エラーハンドリングの統一
- すべてのエラーが適切なエラー型で処理される
- エラーログが適切に記録される
- ユーザーへのエラーメッセージが適切に表示される
- すべての既存テストが通過する

### Phase 7: サービス層のリファクタリング
- サービス間の依存関係が明確になる
- テストの容易性が向上する
- コードの再利用性が向上する
- すべての既存テストが通過する

### Phase 8: APIルート層のリファクタリング
- バリデーションロジックが統一される
- ビジネスロジックがサービス層に分離される
- エラーハンドリングが統一される
- すべての既存テストが通過する

### Phase 9: フロントエンドの最適化
- 不要な再レンダリングが50%以上削減される
- バンドルサイズが10%以上削減される（可能な場合）
- すべての既存テストが通過する

### Phase 10: テストカバレッジの向上
- テストカバレッジが80%以上になる
- すべてのエッジケースがテストされる
- テストの実行時間が許容範囲内である
- CI/CDでカバレッジが可視化される

### Phase 11: ドキュメントの整備
- すべての公開APIにJSDocコメントが追加される
- APIドキュメントが整備される
- アーキテクチャドキュメントが最新の状態になる
- READMEが分かりやすくなる

## 6. リスク管理

### 6.1 潜在的なリスク

1. **破壊的変更**
   - リファクタリングにより、既存のAPIが動作しなくなる可能性
   - **対策**: 段階的な移行、包括的なテスト

2. **パフォーマンスの劣化**
   - 型ガードやバリデーションの追加により、パフォーマンスが劣化する可能性
   - **対策**: パフォーマンステストの実施、ベンチマークの比較

3. **テストの失敗**
   - リファクタリングにより、既存のテストが失敗する可能性
   - **対策**: テストの更新、段階的なリファクタリング

4. **工数の超過**
   - 予想以上の工数がかかる可能性
   - **対策**: 段階的な実装、優先順位の明確化

### 6.2 ロールバック計画

各Phaseは独立して実装できるため、問題が発生した場合は該当Phaseのみをロールバック可能。

## 7. 関連ドキュメント

- [既存のリファクタリング計画 v2](./refactoring_plan_v2.md)
- [既存のリファクタリング計画](./refactoring_plan.md)
- [機能改善計画](./improvement_plan.md)
- [Phase 4実装計画](./implementation/phase4_implementation_plan.md)

## 8. 進捗管理

各Phaseの進捗は以下のように管理します：

- **未着手**: ⬜
- **進行中**: 🟦
- **完了**: ✅
- **保留**: ⏸️

### 進捗状況

- Phase 5: ✅ 完了（2025-12-29）
  - 型ガード関数の作成完了
  - バリデーション関数の拡張完了
  - マッピング関数の追加完了（RSSFeed, RSSItem, WebClip, Link, NoteMD）
  - すべてのDBモジュールで型アサーションを削減（テストファイル以外で0件）
  - すべてのテストが通過
- Phase 6: ⬜ 未着手
- Phase 7: ⬜ 未着手
- Phase 8: ⬜ 未着手
- Phase 9: ⬜ 未着手
- Phase 10: ⬜ 未着手
- Phase 11: ⬜ 未着手

---

*このドキュメントは継続的なリファクタリング計画です。各Phaseの完了後、次のPhaseに進む前にレビューと評価を行ってください。*

