# リファクタリング計画 v2

作成日: 2025-12-29
最終更新: 2025-12-29

**実装状況**: Phase 1-4 完了 ✅

## 1. 概要

このドキュメントは、Locusプロジェクトの継続的なリファクタリング計画をまとめたものです。既存のPhase 1-4が完了したことを前提に、さらなるコード品質向上、保守性の向上、パフォーマンスの最適化を目的としています。

## 2. 現状分析

### 2.1 既に完了した改善（Phase 1-4）

既存のリファクタリング計画（`docs/refactoring_plan.md`）でPhase 1-4が完了しています：

- ✅ **Phase 1**: コード品質の向上（型安全性、テスト、ドキュメント）
- ✅ **Phase 2**: パフォーマンスの最適化（バンドルサイズ、レンダリング、APIリクエスト）
- ✅ **Phase 3**: コードの一貫性の向上（命名規則、コードスタイル）
- ✅ **Phase 4**: アーキテクチャの改善（状態管理、関心の分離、エラーハンドリング）

### 2.2 新たに特定された改善点

コードベースを再評価した結果、以下の改善点を特定しました：

#### 2.2.1 データベース層の重複コード

**問題点**:
- `apps/api/src/db/notes.ts` の `listNotes`, `listNotesByTags`, `listPublicNotes` で、SQLクエリ構築と結果マッピングのパターンが重複している
- 行から `NoteCore` へのマッピングロジックが各関数で重複している（128-136行、177-185行、214-222行）
- 同様のパターンが他のDBモジュール（`tags.ts`, `files.ts` など）でも見られる

**影響範囲**:
- `apps/api/src/db/notes.ts`
- `apps/api/src/db/tags.ts`
- `apps/api/src/db/files.ts`
- `apps/api/src/db/rss.ts`
- `apps/api/src/db/web-clips.ts`

**改善効果**:
- コードの重複削減（DRY原則）
- バグ修正時の影響範囲の縮小
- 新しいクエリ追加時の一貫性向上

#### 2.2.2 型安全性の向上

**問題点**:
- データベースの行からオブジェクトへのマッピングで、型アサーション（`as`）が多用されている
- `row.id as string`, `row.type as NoteType` などの型アサーションが各所で使用されている
- 型安全性が不十分で、実行時エラーのリスクがある

**影響範囲**:
- すべての `apps/api/src/db/*.ts` ファイル

**改善効果**:
- 型安全性の向上
- コンパイル時エラー検出の強化
- 実行時エラーのリスク削減

#### 2.2.3 データベースクエリビルダーの導入

**問題点**:
- SQLクエリの構築が文字列連結で行われている
- クエリの可読性が低い
- SQLインジェクション対策はプレースホルダーで行われているが、クエリ構築の安全性をさらに向上できる

**影響範囲**:
- すべての `apps/api/src/db/*.ts` ファイル

**改善効果**:
- クエリの可読性向上
- クエリ構築の安全性向上
- クエリの再利用性向上

#### 2.2.4 エラーハンドリングの統一

**問題点**:
- データベース操作でのエラーハンドリングが統一されていない
- 一部の関数で `throw new Error()` が使用されているが、エラーの種類が不明確
- エラーログの記録が不十分

**影響範囲**:
- すべての `apps/api/src/db/*.ts` ファイル
- `apps/api/src/routes/*.ts` ファイル

**改善効果**:
- エラーハンドリングの一貫性向上
- デバッグの容易化
- ユーザーへの適切なエラーメッセージ提供

#### 2.2.5 テストカバレッジの向上

**問題点**:
- テストファイルは存在するが、カバレッジが不明
- エッジケースのテストが不足している可能性
- 統合テストの充実が必要

**影響範囲**:
- すべてのテストファイル

**改善効果**:
- バグの早期発見
- リファクタリング時の安全性向上
- コード品質の可視化

#### 2.2.6 フロントエンドの状態管理の最適化

**問題点**:
- `apps/web/src/lib/stores/notes.ts` で、`fileToNoteCore` 関数が複数の `derived` ストアで重複して使用されている
- `filteredNotes`, `totalPages`, `filteredCount` で同じ変換ロジックが重複している

**影響範囲**:
- `apps/web/src/lib/stores/notes.ts`

**改善効果**:
- パフォーマンスの向上（重複計算の削減）
- コードの可読性向上

## 3. リファクタリング計画

### 3.1 Phase 5: データベース層のリファクタリング

**目的**: データベース層の重複コード削減、型安全性向上、クエリビルダーの導入

**タスク**:

1. **共通マッピング関数の作成**
   - `apps/api/src/db/utils/mappers.ts` を作成
   - `NoteCore`, `Tag`, `File` などのマッピング関数を共通化
   - 型安全なマッピング関数を実装

2. **クエリビルダーの導入**
   - シンプルなクエリビルダーユーティリティを作成（`apps/api/src/db/utils/query-builder.ts`）
   - 既存のクエリを段階的に移行
   - SQLインジェクション対策の強化

3. **重複コードの削減**
   - `listNotes`, `listNotesByTags`, `listPublicNotes` の共通化
   - 他のDBモジュールの重複コードも同様に削減

4. **型安全性の向上**
   - 型アサーションの削減
   - より厳密な型定義の導入
   - バリデーション関数の追加

**影響範囲**:
- `apps/api/src/db/*.ts` すべて
- `apps/api/src/routes/*.ts`（影響は最小限）

**推定工数**: 12-16時間

**実装ステップ**:
1. 共通マッピング関数の作成とテスト
2. クエリビルダーの実装とテスト
3. `notes.ts` のリファクタリング
4. 他のDBモジュールのリファクタリング
5. 既存テストの更新と新規テストの追加

### 3.2 Phase 6: エラーハンドリングの統一

**目的**: データベース層とAPI層でのエラーハンドリングの統一

**タスク**:

1. **カスタムエラー型の定義**
   - `apps/api/src/utils/errors.ts` を作成
   - `DatabaseError`, `NotFoundError`, `ValidationError` などのエラー型を定義
   - エラーの種類に応じた適切なHTTPステータスコードのマッピング

2. **エラーハンドリングミドルウェアの改善**
   - `apps/api/src/middleware/error-handler.ts` の改善
   - エラーログの記録
   - ユーザーへの適切なエラーメッセージの提供

3. **データベース層でのエラーハンドリング**
   - すべてのDB関数で統一されたエラーハンドリング
   - エラーログの記録

**影響範囲**:
- `apps/api/src/db/*.ts` すべて
- `apps/api/src/routes/*.ts` すべて
- `apps/api/src/middleware/*.ts`

**推定工数**: 6-8時間

**実装ステップ**:
1. カスタムエラー型の定義
2. エラーハンドリングミドルウェアの改善
3. データベース層でのエラーハンドリングの統一
4. API層でのエラーハンドリングの統一
5. テストの追加

### 3.3 Phase 7: テストカバレッジの向上

**目的**: テストカバレッジの向上、エッジケースのテスト追加

**タスク**:

1. **テストカバレッジの測定**
   - カバレッジツールの導入（`c8` または `nyc`）
   - 現在のカバレッジを測定
   - カバレッジレポートの生成

2. **不足しているテストケースの追加**
   - エッジケースのテスト
   - エラーハンドリングのテスト
   - 統合テストの充実

3. **テストのリファクタリング**
   - テストヘルパーの改善
   - テストデータの共通化
   - テストの可読性向上

**影響範囲**:
- すべてのテストファイル
- テスト設定ファイル

**推定工数**: 8-10時間

**実装ステップ**:
1. カバレッジツールの導入と設定
2. 現在のカバレッジの測定
3. 不足しているテストケースの特定
4. テストケースの追加
5. テストのリファクタリング

### 3.4 Phase 8: フロントエンドの最適化

**目的**: フロントエンドの状態管理とパフォーマンスの最適化

**タスク**:

1. **状態管理の最適化**
   - `apps/web/src/lib/stores/notes.ts` の最適化
   - `fileToNoteCore` の重複計算の削減
   - `derived` ストアの最適化

2. **パフォーマンスの最適化**
   - 不要な再レンダリングの削減
   - メモ化の適切な使用
   - バンドルサイズの最適化

3. **コードの整理**
   - 未使用コードの削除
   - コンポーネントの分割（必要に応じて）

**影響範囲**:
- `apps/web/src/lib/stores/*.ts`
- `apps/web/src/routes/*.svelte`
- `apps/web/src/lib/components/*.svelte`

**推定工数**: 6-8時間

**実装ステップ**:
1. 状態管理の最適化
2. パフォーマンスの測定と最適化
3. コードの整理
4. テストの更新

## 4. 実装順序

推奨される実装順序：

1. **Phase 5** - データベース層のリファクタリング（基盤となる改善）
2. **Phase 6** - エラーハンドリングの統一（Phase 5の後に実施しやすい）
3. **Phase 7** - テストカバレッジの向上（Phase 5-6の変更をテスト）
4. **Phase 8** - フロントエンドの最適化（独立して実施可能）

## 5. 成功基準

各Phaseの成功基準：

### Phase 5: データベース層のリファクタリング
- 重複コードが50%以上削減される
- 型アサーションが50%以上削減される
- すべての既存テストが通過する
- 新しいクエリの追加が容易になる

### Phase 6: エラーハンドリングの統一
- すべてのエラーが適切なエラー型で処理される
- エラーログが適切に記録される
- ユーザーへのエラーメッセージが適切に表示される
- すべての既存テストが通過する

### Phase 7: テストカバレッジの向上
- テストカバレッジが80%以上になる
- すべてのエッジケースがテストされる
- テストの実行時間が許容範囲内である

### Phase 8: フロントエンドの最適化
- 不要な再レンダリングが50%以上削減される
- バンドルサイズが10%以上削減される（可能な場合）
- すべての既存テストが通過する

## 6. リスク管理

### 6.1 潜在的なリスク

1. **破壊的変更**
   - データベース層のリファクタリングにより、既存のAPIが動作しなくなる可能性
   - **対策**: 段階的な移行、包括的なテスト

2. **パフォーマンスの劣化**
   - クエリビルダーの導入により、パフォーマンスが劣化する可能性
   - **対策**: パフォーマンステストの実施、ベンチマークの比較

3. **テストの失敗**
   - リファクタリングにより、既存のテストが失敗する可能性
   - **対策**: テストの更新、段階的なリファクタリング

### 6.2 ロールバック計画

各Phaseは独立して実装できるため、問題が発生した場合は該当Phaseのみをロールバック可能。

## 7. 関連ドキュメント

- [既存のリファクタリング計画](./refactoring_plan.md)
- [機能改善計画](./improvement_plan.md)
- [Phase 4実装計画](./implementation/phase4_implementation_plan.md)

---

*このドキュメントは継続的なリファクタリング計画です。各Phaseの完了後、次のPhaseに進む前にレビューと評価を行ってください。*

